# Security Vulnerability Prevention Implementation Guide

**Friction Point**: AI generates code with security vulnerabilities, exposes secrets, creates unsafe patterns  
**Solution**: Security-first templates, automated scanning, safe pattern enforcement  
**Implementation Time**: 12-15 minutes

## Table of Contents

1. [Quick Implementation](#quick-implementation)
2. [Step-by-Step Implementation](#step-by-step-implementation)
  3. [1. Configure Security Scanning (5 min)](#1-configure-security-scanning-5-min)
  4. [2. Implement Safe Coding Patterns (4 min)](#2-implement-safe-coding-patterns-4-min)
  5. [3. Template Security Patterns (3 min)](#3-template-security-patterns-3-min)
  6. [4. Validation and Testing (2 min)](#4-validation-and-testing-2-min)
7. [Advanced Security Configuration](#advanced-security-configuration)
  8. [Custom Security Rules](#custom-security-rules)
  9. [AI Security Prompts](#ai-security-prompts)
  10. [Security Testing Integration](#security-testing-integration)
11. [Integration with Existing Projects](#integration-with-existing-projects)
  12. [Minimal Security Integration](#minimal-security-integration)
  13. [Comprehensive Security Integration](#comprehensive-security-integration)
  14. [Team Security Standards](#team-security-standards)
15. [Common Security Patterns](#common-security-patterns)
  16. [Safe API Integration](#safe-api-integration)
  17. [Safe Form Handling](#safe-form-handling)
18. [Troubleshooting](#troubleshooting)
19. [Security Metrics](#security-metrics)
20. [Related Solutions](#related-solutions)

## Quick Implementation

```bash
# 1. Set up security scanning
npm run security:check

# 2. Configure safe patterns
npm run setup:hooks

# 3. Validate security
npm run check:all && npm run check:imports
```

## Step-by-Step Implementation

### 1. Configure Security Scanning (5 min)

**Set up automated security checks:**
```bash
# Run security audit
npm run security:check

# Set up pre-commit security validation
npm run setup:hooks
# This configures git hooks to run security checks before commits
```

**Configure security-focused enforcement:**
```bash
# Enable logging enforcement (prevents console.log with secrets)
npm run setup:log-enforcer

# Check current security status
npm run enforcement:status
```

### 2. Implement Safe Coding Patterns (4 min)

**Configure import validation:**
```bash
# Test import security enforcement
npm run check:imports
# Blocks: console.log(), require() in ES6, unsafe imports
```

**Set up environment variable safety:**
```bash
# Create secure environment template
cp .env.example .env.local

# Configure safe environment handling
echo "# Never commit .env.local files" >> .gitignore
echo ".env.local" >> .gitignore
echo ".env.*.local" >> .gitignore
```

**Example secure environment pattern:**
```typescript
// ✅ Good: Safe environment access
const API_KEY = process.env.VITE_API_KEY;
if (!API_KEY) {
  throw new Error('VITE_API_KEY environment variable is required');
}

// ❌ Bad: Hardcoded secrets
const API_KEY = 'sk-1234567890abcdef'; // This would be blocked
```

### 3. Template Security Patterns (3 min)

**Review security-enhanced templates:**
```bash
# Examine secure component template
cat templates/component/Component.tsx.hbs
# Look for: input validation, XSS prevention, safe defaults
```

**Example secure component pattern:**
```typescript
interface {{pascalCase name}}Props {
  // Input validation required
  userId: string;
  userInput?: string;
  onAction?: (sanitizedInput: string) => void;
}

export const {{pascalCase name}}: React.FC<{{pascalCase name}}Props> = ({
  userId,
  userInput = '',
  onAction
}) => {
  // Input sanitization
  const sanitizedInput = useMemo(() => 
    DOMPurify.sanitize(userInput), [userInput]
  );

  // Safe event handling
  const handleAction = useCallback(() => {
    if (onAction && sanitizedInput.trim()) {
      onAction(sanitizedInput);
    }
  }, [onAction, sanitizedInput]);

  return (
    <div>
      {/* Safe HTML rendering */}
      <div dangerouslySetInnerHTML={{ __html: sanitizedInput }} />
      
      {/* CSRF protection for forms */}
      <form onSubmit={handleAction}>
        <input type="hidden" name="_token" value={csrfToken} />
        {/* Form content */}
      </form>
    </div>
  );
};
```

### 4. Validation and Testing (2 min)

**Test security enforcement:**
```bash
# Try creating insecure code (should be blocked)
echo "console.log('API_KEY:', process.env.SECRET_KEY)" > test-security.js
npm run check:all  # Should detect and flag this

# Clean up test
rm test-security.js
```

**Verify comprehensive security:**
```bash
npm run check:all
# Includes: import validation, logging checks, documentation security
```

## Advanced Security Configuration

### Custom Security Rules

**Configure logging enforcement:**
```bash
# Set up custom log enforcer rules
npm run setup:log-enforcer

# Edit generated config
# .log-enforcer-config.json allows customization
```

**Example log enforcer config:**
```json
{
  "level": "strict",
  "allowedPatterns": [
    "logger.info",
    "logger.error", 
    "logger.debug"
  ],
  "blockedPatterns": [
    "console.log",
    "console.error",
    "print(",
    "alert("
  ],
  "secretDetection": {
    "enabled": true,
    "patterns": [
      "api[_-]?key",
      "secret[_-]?key",
      "password",
      "token"
    ]
  }
}
```

### AI Security Prompts

**Security-focused prompt templates:**
```markdown
Create [ComponentName] with security requirements:
1. Validate all user inputs
2. Sanitize any HTML content
3. Use proper error handling without exposing internals
4. Include CSRF protection for forms
5. Never log sensitive data
6. Use TypeScript for type safety
```

**Context for secure AI generation:**
```bash
# Load security context
npm run context -- --include-security

# Use security-aware prompts
# Good: "Create secure user input component with validation"
# ❌ Bad: "Create input component" (no security context)
```

### Security Testing Integration

**Add security tests to generators:**
```typescript
// Generated test includes security scenarios
describe('{{pascalCase name}} Security', () => {
  it('sanitizes user input', () => {
    const maliciousInput = '<script>alert("xss")</script>';
    render(<{{pascalCase name}} userInput={maliciousInput} />);
    
    // Should not execute script
    expect(screen.queryByText('xss')).not.toBeInTheDocument();
  });

  it('validates required props', () => {
    expect(() => {
      render(<{{pascalCase name}} userId="" />);
    }).toThrow('Invalid userId');
  });

  it('prevents XSS in dynamic content', () => {
    const xssAttempt = 'javascript:alert("xss")';
    render(<{{pascalCase name}} href={xssAttempt} />);
    
    const link = screen.getByRole('link');
    expect(link.getAttribute('href')).not.toContain('javascript:');
  });
});
```

## Integration with Existing Projects

### Minimal Security Integration
```bash
# Add basic security checks
npm run check:all           # Check for unsafe logging
npm run security:check       # Run security audit
cp .env.example .env.local   # Set up secure environment
```

### Comprehensive Security Integration
```bash
# Full security enforcement
npm run setup:hooks                    # Git hooks
npm run setup:log-enforcer            # Logging enforcement
npm run enforcement:config set-level FULL # Maximum security
```

### Team Security Standards

**Establish team security baseline:**
```bash
# Create team security config
npm run enforcement:config set-team-security STRICT

# Document security patterns
cp docs/guides/security/ your-project/docs/security/
```

## Common Security Patterns

### Safe API Integration
```typescript
// ✅ Secure API service pattern
class ApiService {
  private readonly baseUrl: string;
  private readonly apiKey: string;

  constructor() {
    this.baseUrl = process.env.VITE_API_BASE_URL || '';
    this.apiKey = process.env.VITE_API_KEY || '';
    
    if (!this.baseUrl || !this.apiKey) {
      throw new Error('Missing required environment variables');
    }
  }

  async fetchUserData(userId: string): Promise<UserData> {
    // Input validation
    if (!userId || typeof userId !== 'string') {
      throw new Error('Invalid userId');
    }

    try {
      const response = await fetch(`${this.baseUrl}/users/${encodeURIComponent(userId)}`, {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        // Don't expose internal error details
        throw new Error('Failed to fetch user data');
      }

      return await response.json();
    } catch (error) {
      // Log error securely (without exposing sensitive data)
      logger.error('API fetch failed', { userId: userId.substring(0, 4) + '***' });
      throw error;
    }
  }
}
```

### Safe Form Handling
```typescript
// ✅ Secure form component pattern
export const SecureForm: React.FC<FormProps> = ({ onSubmit }) => {
  const [csrfToken] = useState(() => generateCSRFToken());
  
  const handleSubmit = useCallback(async (event: FormEvent) => {
    event.preventDefault();
    
    const formData = new FormData(event.target as HTMLFormElement);
    
    // Validate CSRF token
    if (formData.get('_token') !== csrfToken) {
      throw new Error('Invalid CSRF token');
    }

    // Sanitize all text inputs
    const sanitizedData = Object.fromEntries(
      Array.from(formData.entries()).map(([key, value]) => [
        key,
        typeof value === 'string' ? DOMPurify.sanitize(value) : value
      ])
    );

    await onSubmit(sanitizedData);
  }, [csrfToken, onSubmit]);

  return (
    <form onSubmit={handleSubmit}>
      <input type="hidden" name="_token" value={csrfToken} />
      {/* Form fields */}
    </form>
  );
};
```

## Troubleshooting

**Issue**: Security checks are too strict  
**Solution**: Customize enforcement level (`npm run enforcement:config`), add specific exceptions

**Issue**: False positive security warnings  
**Solution**: Update patterns in `.log-enforcer-config.json`, add to allowlist

**Issue**: Performance impact from security scanning  
**Solution**: Run security checks in CI/CD only (`npm run security:check --ci`)

**Issue**: AI generates insecure code despite context  
**Solution**: Use explicit security prompts, reference secure examples in prompts

## Security Metrics

**Before security enforcement:**
- Security issues found: During security review/production
- Time to identify vulnerabilities: 2-4 weeks
- False positive rate: N/A (manual review)

**After security enforcement:**
- Security issues found: During development (pre-commit)
- Time to identify vulnerabilities: Real-time
- False positive rate: <5% (configurable patterns)

## Related Solutions

- [Code Generation Quality](code-generation-quality.md) - Overall code quality patterns
- [Context Window Optimization](context-window-optimization.md) - Security-aware context loading
- [Testing Pattern Implementation](testing-pattern-implementation.md) - Security testing patterns