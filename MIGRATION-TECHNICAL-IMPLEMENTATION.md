# Technical Implementation Details for AIPatternEnforcer Migration

## Overview

This document provides the detailed technical implementation for migrating AIPatternEnforcer from a hybrid architecture to a clean meta-project/starter separation.

## Current State Technical Audit

### File System Analysis

```
Current Problematic Structure:
/
â”œâ”€â”€ components/              # âŒ App code in root
â”‚   â”œâ”€â”€ AIChat/             # Generated by onboarding
â”‚   â””â”€â”€ TestValidation/     # Generated by examples
â”œâ”€â”€ package.json            # âŒ 166 dependencies (mixed concerns)
â”œâ”€â”€ jest.config.js          # âŒ Mixed Node + React testing
â”œâ”€â”€ tools/                  # âœ… Meta-project tools (correct)
â”œâ”€â”€ templates/              # â“ Confusing name (implies templates, not starters)
â””â”€â”€ scripts/                # â“ Mixed meta-project and app scripts
```

### Dependency Analysis

**Current Root package.json Issues**:

```json
{
  "dependencies": {
    // âŒ UI Framework (52 packages)
    "@radix-ui/*": "~30 packages",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",

    // âŒ React Ecosystem (15 packages)
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "next": "14.1.0",

    // âŒ State Management (8 packages)
    "zustand": "^4.5.7",
    "@tanstack/react-query": "^5.83.0",

    // âœ… Meta-project tools (should stay)
    "commander": "^11.1.0",
    "handlebars": "^4.7.8",
    "chalk": "^4.1.2"
  }
}
```

### Script Reference Analysis

**Package.json scripts that need updating**:

```json
{
  "scripts": {
    // References to tools/
    "g:c": "node tools/generators/component-generator.js",
    "setup:hooks": "node tools/setup/git-hooks.js",

    // References to scripts/
    "context": "node scripts/dev/context-dump.js",
    "validate": "node scripts/dev/validate-all.js",

    // Mixed concerns
    "test": "jest", // Includes React tests
    "build": "next build" // âŒ App build in meta-project
  }
}
```

## Implementation Phases

### Phase 1: Foundation Setup (Day 1-2)

#### 1.1 Create Starter Template Structure

```bash
#!/bin/bash
# setup-starter-structure.sh

# Create minimal-ai-app starter
mkdir -p starters/minimal-ai-app/{app,components,lib,public,scripts}

# Create starter-specific configuration files
cat > starters/minimal-ai-app/package.json << 'EOF'
{
  "name": "ai-app",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "g:c": "node ../../meta/generators/component-generator.js"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "next": "14.1.0",
    "typescript": "^5.3.3"
  }
}
EOF

# Create .env.example with hooks enabled by default
cat > starters/minimal-ai-app/.env.example << 'EOF'
# Hook Protection (enabled by default for safety)
HOOKS_DISABLED=false

# Database
DATABASE_URL=postgresql://localhost:5432/myapp

# AI Services
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
EOF

# Create starter-specific jest.config.js
cat > starters/minimal-ai-app/jest.config.js << 'EOF'
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
};
EOF
```

#### 1.2 Create Migration Detection System

```javascript
// migration/lib/project-state-detector.js
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

class ProjectStateDetector {
  constructor(projectRoot = process.cwd()) {
    this.root = projectRoot;
  }

  async detectState() {
    const state = {
      type: "unknown",
      hasUserComponents: false,
      hasModifiedComponents: false,
      hasUncommittedChanges: false,
      components: [],
      recommendations: [],
    };

    // Check if this is the meta-project
    if (this.isMetaProject()) {
      state.type = "meta-project";

      // Check for user components
      const componentsDir = path.join(this.root, "components");
      if (fs.existsSync(componentsDir)) {
        state.hasUserComponents = true;
        state.components = this.scanComponents(componentsDir);
      }

      // Check git status
      try {
        const gitStatus = execSync("git status --porcelain", {
          cwd: this.root,
          encoding: "utf8",
        });

        state.hasUncommittedChanges = gitStatus.length > 0;
        state.hasModifiedComponents = gitStatus.includes("components/");
      } catch (e) {
        // Not a git repo or git not available
      }

      // Add recommendations
      if (state.hasUserComponents) {
        state.recommendations.push({
          priority: "high",
          message: "Move components to starters/minimal-ai-app/",
          command: "npm run migrate:components",
        });
      }
    }

    return state;
  }

  isMetaProject() {
    // Multiple indicators that this is the meta-project
    const indicators = [
      fs.existsSync(path.join(this.root, "tools/generators")),
      fs.existsSync(path.join(this.root, "GOAL.md")),
      fs.existsSync(path.join(this.root, "templates")) ||
        fs.existsSync(path.join(this.root, "starters")),
    ];

    return indicators.filter(Boolean).length >= 2;
  }

  scanComponents(dir) {
    const components = [];

    if (!fs.existsSync(dir)) return components;

    fs.readdirSync(dir).forEach((item) => {
      const itemPath = path.join(dir, item);
      const stat = fs.statSync(itemPath);

      if (stat.isDirectory() && !item.startsWith(".")) {
        components.push({
          name: item,
          path: itemPath,
          hasTests: fs.existsSync(path.join(itemPath, `${item}.test.tsx`)),
          hasStories: fs.existsSync(path.join(itemPath, `${item}.stories.tsx`)),
        });
      }
    });

    return components;
  }
}

module.exports = ProjectStateDetector;
```

#### 1.3 Create Component Migration Tool

```javascript
// migration/lib/component-migrator.js
const fs = require("fs-extra");
const path = require("path");
const { execSync } = require("child_process");

class ComponentMigrator {
  constructor(sourceRoot, targetRoot) {
    this.sourceRoot = sourceRoot;
    this.targetRoot = targetRoot;
  }

  async migrateComponents(options = {}) {
    const {
      preserveGitHistory = true,
      updateImports = true,
      backupFirst = true,
    } = options;

    const results = {
      success: false,
      migratedComponents: [],
      errors: [],
      backupPath: null,
    };

    try {
      // Step 1: Backup if requested
      if (backupFirst) {
        results.backupPath = await this.createBackup();
      }

      // Step 2: Ensure target directory exists
      const targetComponentsDir = path.join(this.targetRoot, "components");
      await fs.ensureDir(targetComponentsDir);

      // Step 3: Get list of components
      const sourceComponentsDir = path.join(this.sourceRoot, "components");
      const components = await this.getComponents(sourceComponentsDir);

      // Step 4: Migrate each component
      for (const component of components) {
        try {
          if (preserveGitHistory) {
            await this.migrateWithGitHistory(component);
          } else {
            await this.migrateWithCopy(component);
          }

          results.migratedComponents.push(component.name);
        } catch (error) {
          results.errors.push({
            component: component.name,
            error: error.message,
          });
        }
      }

      // Step 5: Update imports if requested
      if (updateImports && results.migratedComponents.length > 0) {
        await this.updateImportPaths();
      }

      results.success = results.errors.length === 0;
    } catch (error) {
      results.errors.push({
        component: "migration-process",
        error: error.message,
      });
    }

    return results;
  }

  async createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const backupPath = path.join(this.sourceRoot, `backup-${timestamp}`);

    await fs.copy(
      path.join(this.sourceRoot, "components"),
      path.join(backupPath, "components"),
    );

    return backupPath;
  }

  async migrateWithGitHistory(component) {
    const sourcePath = component.path;
    const targetPath = path.join(this.targetRoot, "components", component.name);

    // Use git mv to preserve history
    try {
      execSync(`git mv "${sourcePath}" "${targetPath}"`, {
        cwd: this.sourceRoot,
        stdio: "pipe",
      });
    } catch (error) {
      // If git mv fails, fall back to regular copy
      await this.migrateWithCopy(component);
    }
  }

  async migrateWithCopy(component) {
    const sourcePath = component.path;
    const targetPath = path.join(this.targetRoot, "components", component.name);

    await fs.copy(sourcePath, targetPath);
  }

  async updateImportPaths() {
    // This would scan all files and update import paths
    // Implementation depends on project structure
    console.log("Import path updates would be performed here");
  }

  async getComponents(componentsDir) {
    const components = [];

    if (!(await fs.pathExists(componentsDir))) {
      return components;
    }

    const items = await fs.readdir(componentsDir);

    for (const item of items) {
      const itemPath = path.join(componentsDir, item);
      const stat = await fs.stat(itemPath);

      if (stat.isDirectory() && !item.startsWith(".")) {
        components.push({
          name: item,
          path: itemPath,
        });
      }
    }

    return components;
  }
}

module.exports = ComponentMigrator;
```

### Phase 2: Smart Generator Updates (Day 3-4)

#### 2.1 Context-Aware Component Generator

```javascript
// meta/generators/component-generator-v2.js
const path = require("path");
const fs = require("fs");

class ContextAwareGenerator {
  constructor() {
    this.projectRoot = process.cwd();
  }

  detectContext() {
    // Indicators of being in meta-project
    const metaIndicators = [
      "tools/generators",
      "starters",
      "GOAL.md",
      "CLAUDE.md",
    ].filter((p) => fs.existsSync(path.join(this.projectRoot, p)));

    // Indicators of being in a starter/user project
    const starterIndicators = ["app", ".next", "next.config.js"].filter((p) =>
      fs.existsSync(path.join(this.projectRoot, p)),
    );

    return {
      isMetaProject: metaIndicators.length >= 2,
      isStarterProject:
        starterIndicators.length >= 2 && metaIndicators.length === 0,
      confidence: Math.max(metaIndicators.length, starterIndicators.length) / 3,
    };
  }

  async generate(componentName, options = {}) {
    const context = this.detectContext();

    if (context.isMetaProject) {
      this.handleMetaProjectGeneration(componentName);
      return;
    }

    if (!context.isStarterProject) {
      this.handleUncertainContext(componentName, context);
      return;
    }

    // Proceed with normal generation
    await this.generateComponent(componentName, options);
  }

  handleMetaProjectGeneration(componentName) {
    console.error(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âš ï¸  Wrong Location!                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ You're trying to generate a component in the meta-project.    â•‘
â•‘                                                               â•‘
â•‘ AIPatternEnforcer is a tool that CREATES projects.           â•‘
â•‘ You don't develop your app here.                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ To generate "${componentName}":                               â•‘
â•‘                                                               â•‘
â•‘ Option 1: Create a new project (recommended)                  â•‘
â•‘   npx create-ai-app my-project                               â•‘
â•‘   cd my-project                                              â•‘
â•‘   npm run g:c ${componentName}                               â•‘
â•‘                                                               â•‘
â•‘ Option 2: Use existing starter                                â•‘
â•‘   cd starters/minimal-ai-app                                 â•‘
â•‘   npm run g:c ${componentName}                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);
    process.exit(1);
  }

  handleUncertainContext(componentName, context) {
    console.warn(`
âš ï¸  Uncertain project context (confidence: ${(context.confidence * 100).toFixed(0)}%)

Not sure if this is the right place to generate components.

If this is a new AI project:
  1. Make sure you're in your project directory
  2. Run: npm run g:c ${componentName}

If you're in AIPatternEnforcer:
  1. Create a new project: npx create-ai-app my-project
  2. Generate components there

Continue anyway? (y/N)
    `);

    // Would read user input here
  }
}
```

#### 2.2 Create Project Generator (create-ai-app)

```javascript
#!/usr/bin/env node
// bin/create-ai-app.js

const { Command } = require("commander");
const inquirer = require("inquirer");
const chalk = require("chalk");
const fs = require("fs-extra");
const path = require("path");
const { execSync } = require("child_process");
const ora = require("ora");

class ProjectCreator {
  constructor() {
    this.sourceRoot = path.join(__dirname, "..");
    this.starters = this.getAvailableStarters();
  }

  getAvailableStarters() {
    const startersDir = path.join(this.sourceRoot, "starters");

    if (!fs.existsSync(startersDir)) {
      return [];
    }

    return fs
      .readdirSync(startersDir)
      .filter((dir) => {
        const starterPath = path.join(startersDir, dir);
        return (
          fs.statSync(starterPath).isDirectory() &&
          fs.existsSync(path.join(starterPath, "package.json"))
        );
      })
      .map((dir) => {
        const packageJson = require(
          path.join(startersDir, dir, "package.json"),
        );
        return {
          name: dir,
          description: packageJson.description || "No description",
          path: path.join(startersDir, dir),
        };
      });
  }

  async create() {
    console.log(chalk.cyan.bold("\nðŸš€ Create AI App\n"));

    // Get project configuration
    const config = await this.getProjectConfig();

    // Create project
    const spinner = ora("Creating project...").start();

    try {
      await this.createProject(config);
      spinner.succeed("Project created");

      // Setup project
      await this.setupProject(config);

      // Show success message
      this.showSuccess(config);
    } catch (error) {
      spinner.fail("Project creation failed");
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  }

  async getProjectConfig() {
    const answers = await inquirer.prompt([
      {
        name: "projectName",
        type: "input",
        message: "Project name:",
        default: "my-ai-app",
        validate: (input) => {
          if (!/^[a-z0-9-_]+$/.test(input)) {
            return "Project name can only contain lowercase letters, numbers, hyphens, and underscores";
          }
          if (fs.existsSync(input)) {
            return `Directory ${input} already exists`;
          }
          return true;
        },
      },
      {
        name: "starter",
        type: "list",
        message: "Choose a starter template:",
        choices: this.starters.map((s) => ({
          name: `${s.name} - ${s.description}`,
          value: s.name,
        })),
        default: "minimal-ai-app",
      },
      {
        name: "features",
        type: "checkbox",
        message: "Select additional features:",
        choices: [
          { name: "TypeScript", value: "typescript", checked: true },
          { name: "ESLint", value: "eslint", checked: true },
          { name: "Tailwind CSS", value: "tailwind", checked: true },
          { name: "AI Chat Components", value: "ai-chat" },
          { name: "Document Processing", value: "doc-processing" },
          { name: "Vector Database", value: "vector-db" },
        ],
      },
      {
        name: "aiService",
        type: "list",
        message: "Primary AI service:",
        choices: [
          { name: "OpenAI", value: "openai" },
          { name: "Anthropic Claude", value: "anthropic" },
          { name: "Both", value: "both" },
          { name: "None (add later)", value: "none" },
        ],
      },
      {
        name: "installDeps",
        type: "confirm",
        message: "Install dependencies?",
        default: true,
      },
    ]);

    return answers;
  }

  async createProject(config) {
    const starter = this.starters.find((s) => s.name === config.starter);
    const targetPath = path.join(process.cwd(), config.projectName);

    // Copy starter template
    await fs.copy(starter.path, targetPath, {
      filter: (src) => {
        // Skip node_modules and .next
        const relativePath = path.relative(starter.path, src);
        return (
          !relativePath.includes("node_modules") &&
          !relativePath.includes(".next")
        );
      },
    });

    // Update package.json
    const packageJsonPath = path.join(targetPath, "package.json");
    const packageJson = await fs.readJson(packageJsonPath);

    packageJson.name = config.projectName;
    packageJson.version = "0.1.0";

    // Add selected features
    if (config.features.includes("ai-chat")) {
      packageJson.dependencies["ai"] = "^3.0.0";
    }

    await fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });

    // Create .env from .env.example
    const envExamplePath = path.join(targetPath, ".env.example");
    const envPath = path.join(targetPath, ".env");

    if (await fs.pathExists(envExamplePath)) {
      let envContent = await fs.readFile(envExamplePath, "utf8");

      // Set hooks enabled by default
      envContent = envContent.replace(
        "HOOKS_DISABLED=true",
        "HOOKS_DISABLED=false",
      );

      await fs.writeFile(envPath, envContent);
    }
  }

  async setupProject(config) {
    const projectPath = path.join(process.cwd(), config.projectName);

    process.chdir(projectPath);

    // Initialize git
    const gitSpinner = ora("Initializing git...").start();
    try {
      execSync("git init", { stdio: "pipe" });
      execSync("git add .", { stdio: "pipe" });
      execSync('git commit -m "Initial commit from create-ai-app"', {
        stdio: "pipe",
      });
      gitSpinner.succeed("Git initialized");
    } catch (error) {
      gitSpinner.warn("Git initialization skipped");
    }

    // Install dependencies
    if (config.installDeps) {
      const installSpinner = ora("Installing dependencies...").start();
      try {
        execSync("npm install", { stdio: "pipe" });
        installSpinner.succeed("Dependencies installed");
      } catch (error) {
        installSpinner.fail("Dependency installation failed");
        console.log(chalk.yellow("Run `npm install` manually"));
      }
    }

    // Generate first component
    const componentSpinner = ora("Generating example component...").start();
    try {
      execSync("npm run g:c WelcomeCard", { stdio: "pipe" });
      componentSpinner.succeed("Example component generated");
    } catch (error) {
      componentSpinner.warn("Component generation skipped");
    }
  }

  showSuccess(config) {
    console.log(`
${chalk.green.bold("âœ¨ Success!")} Created ${chalk.cyan(config.projectName)}

${chalk.bold("ðŸ“ Project Structure:")}
  ${config.projectName}/
  â”œâ”€â”€ app/          ${chalk.gray("# Next.js app directory")}
  â”œâ”€â”€ components/   ${chalk.gray("# Your React components")}
  â”œâ”€â”€ lib/          ${chalk.gray("# Utilities and helpers")}
  â””â”€â”€ public/       ${chalk.gray("# Static assets")}

${chalk.bold("ðŸš€ Get Started:")}
  ${chalk.cyan(`cd ${config.projectName}`)}
  ${config.installDeps ? "" : chalk.cyan("npm install")}
  ${chalk.cyan("npm run dev")}

${chalk.bold("ðŸ“š Next Steps:")}
  â€¢ Generate components: ${chalk.cyan("npm run g:c ComponentName")}
  â€¢ Run tests: ${chalk.cyan("npm test")}
  â€¢ Check types: ${chalk.cyan("npm run type-check")}

${chalk.bold("ðŸ›¡ï¸  Protection:")}
  Hooks are ${chalk.green("enabled")} by default.
  Your code is protected from common AI mistakes!

Happy coding! ðŸŽ‰
    `);
  }
}

// CLI setup
const program = new Command();

program
  .name("create-ai-app")
  .description("Create a new AI application from AIPatternEnforcer starters")
  .version("1.0.0")
  .action(async () => {
    const creator = new ProjectCreator();
    await creator.create();
  });

program.parse();
```

### Phase 3: Package.json Cleanup (Day 5)

#### 3.1 Separate Dependencies

```javascript
// scripts/separate-dependencies.js
const fs = require("fs-extra");
const path = require("path");

async function separateDependencies() {
  const rootPackageJson = await fs.readJson("package.json");

  // Define which dependencies belong where
  const metaDependencies = [
    "commander",
    "handlebars",
    "chalk",
    "ora",
    "inquirer",
    "fs-extra",
    "glob",
    "yargs",
  ];

  const starterDependencies = {
    dependencies: {},
    devDependencies: {},
  };

  // Separate dependencies
  Object.entries(rootPackageJson.dependencies || {}).forEach(
    ([pkg, version]) => {
      if (
        metaDependencies.includes(pkg) ||
        (pkg.startsWith("@types/") &&
          metaDependencies.some((m) => pkg.includes(m)))
      ) {
        // Keep in root
      } else {
        // Move to starter
        starterDependencies.dependencies[pkg] = version;
      }
    },
  );

  // Update starter package.json files
  const startersDir = "starters";
  const starters = await fs.readdir(startersDir);

  for (const starter of starters) {
    const starterPackageJsonPath = path.join(
      startersDir,
      starter,
      "package.json",
    );

    if (await fs.pathExists(starterPackageJsonPath)) {
      const starterPackageJson = await fs.readJson(starterPackageJsonPath);

      // Merge dependencies
      starterPackageJson.dependencies = {
        ...starterPackageJson.dependencies,
        ...starterDependencies.dependencies,
      };

      await fs.writeJson(starterPackageJsonPath, starterPackageJson, {
        spaces: 2,
      });
    }
  }

  // Create new minimal root package.json
  const newRootPackageJson = {
    name: "aipattern-enforcer",
    version: rootPackageJson.version,
    description: "Meta-project for creating AI application starters",
    private: true,
    scripts: {
      // Meta-project scripts only
      create: "node bin/create-ai-app.js",
      "test:meta": "jest --projects jest.config.meta.js",
      "lint:meta": "eslint meta/ scripts/",
      "migrate:check": "node migration/scripts/detect-state.js",
      "migrate:run": "node migration/scripts/migrate.js",
    },
    dependencies: Object.fromEntries(
      Object.entries(rootPackageJson.dependencies || {}).filter(([pkg]) =>
        metaDependencies.includes(pkg),
      ),
    ),
    bin: {
      "create-ai-app": "./bin/create-ai-app.js",
    },
  };

  // Write updated package.json files
  await fs.writeJson("package.json.new", newRootPackageJson, { spaces: 2 });

  console.log(
    "Dependencies separated. Review package.json.new before replacing.",
  );
}

separateDependencies().catch(console.error);
```

### Phase 4: Testing & Validation (Day 6-7)

#### 4.1 Migration Test Suite

```javascript
// migration/tests/migration.test.js
const fs = require("fs-extra");
const path = require("path");
const os = require("os");
const { execSync } = require("child_process");
const ProjectStateDetector = require("../lib/project-state-detector");
const ComponentMigrator = require("../lib/component-migrator");

describe("Migration System", () => {
  let testDir;

  beforeEach(async () => {
    // Create temporary test directory
    testDir = path.join(os.tmpdir(), `migration-test-${Date.now()}`);
    await fs.ensureDir(testDir);
  });

  afterEach(async () => {
    // Cleanup
    await fs.remove(testDir);
  });

  describe("ProjectStateDetector", () => {
    it("should detect meta-project correctly", async () => {
      // Setup meta-project structure
      await fs.ensureDir(path.join(testDir, "tools/generators"));
      await fs.writeFile(path.join(testDir, "GOAL.md"), "test");

      const detector = new ProjectStateDetector(testDir);
      const state = await detector.detectState();

      expect(state.type).toBe("meta-project");
    });

    it("should detect user components", async () => {
      // Setup with components
      await fs.ensureDir(path.join(testDir, "tools/generators"));
      await fs.ensureDir(path.join(testDir, "components/TestComponent"));
      await fs.writeFile(
        path.join(testDir, "components/TestComponent/TestComponent.tsx"),
        "export const TestComponent = () => <div>Test</div>;",
      );

      const detector = new ProjectStateDetector(testDir);
      const state = await detector.detectState();

      expect(state.hasUserComponents).toBe(true);
      expect(state.components).toHaveLength(1);
      expect(state.components[0].name).toBe("TestComponent");
    });
  });

  describe("ComponentMigrator", () => {
    it("should migrate components successfully", async () => {
      // Setup source and target
      const sourceDir = path.join(testDir, "source");
      const targetDir = path.join(testDir, "target");

      await fs.ensureDir(sourceDir);
      await fs.ensureDir(targetDir);

      // Create test component
      const componentPath = path.join(sourceDir, "components/TestComponent");
      await fs.ensureDir(componentPath);
      await fs.writeFile(
        path.join(componentPath, "TestComponent.tsx"),
        "export const TestComponent = () => <div>Test</div>;",
      );

      // Run migration
      const migrator = new ComponentMigrator(sourceDir, targetDir);
      const results = await migrator.migrateComponents({
        preserveGitHistory: false, // Can't test git in temp dir
      });

      expect(results.success).toBe(true);
      expect(results.migratedComponents).toContain("TestComponent");

      // Verify component was moved
      const targetComponentPath = path.join(
        targetDir,
        "components/TestComponent/TestComponent.tsx",
      );
      expect(await fs.pathExists(targetComponentPath)).toBe(true);
    });

    it("should create backup when requested", async () => {
      const sourceDir = path.join(testDir, "source");
      await fs.ensureDir(path.join(sourceDir, "components"));

      const migrator = new ComponentMigrator(sourceDir, testDir);
      const results = await migrator.migrateComponents({
        backupFirst: true,
      });

      expect(results.backupPath).toBeTruthy();
      expect(await fs.pathExists(results.backupPath)).toBe(true);
    });
  });
});
```

#### 4.2 End-to-End Migration Test

```javascript
// migration/tests/e2e-migration.test.js
describe("End-to-End Migration", () => {
  it("should handle complete migration workflow", async () => {
    // This would test the entire migration process
    // Including:
    // 1. Detection
    // 2. Backup
    // 3. Migration
    // 4. Validation
    // 5. Cleanup
  });
});
```

### Phase 5: Documentation Updates (Day 8)

#### 5.1 Update Root README.md

````markdown
# AIPatternEnforcer

> ðŸš€ Create AI-powered applications in under 2 minutes

AIPatternEnforcer is a meta-project that generates starter templates for AI applications. Stop fighting with AI coding assistants and start building with confidence.

## Quick Start

```bash
npx create-ai-app my-ai-assistant
cd my-ai-assistant
npm run dev
```
````

That's it! You now have a fully configured AI application with:

- âœ… Hooks enabled by default (protection from AI mistakes)
- âœ… TypeScript configured
- âœ… AI service integration ready
- âœ… Component generators
- âœ… Testing setup

## Available Starters

### minimal-ai-app

Basic AI application with essential features:

- Next.js 14 with App Router
- React 18
- TypeScript
- Tailwind CSS
- AI service integration

### ai-chat-app

Full-featured AI chat interface:

- Everything from minimal-ai-app
- Chat UI components
- Streaming responses
- Conversation management
- Multi-model support

### ai-document-processor

Document processing with AI:

- Everything from minimal-ai-app
- File upload components
- OCR integration
- Document analysis
- Vector search ready

## For Existing Users

If you've been developing directly in AIPatternEnforcer:

```bash
npm run migrate:check  # Check your current state
npm run migrate:run    # Automated migration
```

See [MIGRATION-GUIDE.md](./MIGRATION-GUIDE.md) for details.

## Development

This is the AIPatternEnforcer meta-project. To contribute:

1. Clone this repository
2. Make changes to starters or tools
3. Test with `npm test`
4. Submit PR

**Important**: Don't develop your application here. Use `create-ai-app` to generate a new project.

## Why AIPatternEnforcer?

- **Built for AI Development**: Patterns that work with Claude, Cursor, and Copilot
- **Protection Built-in**: Hooks prevent common AI mistakes
- **Zero Config**: Everything works out of the box
- **Type Safe**: Full TypeScript support
- **Modern Stack**: Next.js 14, React 18, Tailwind CSS

## License

MIT

````

## Rollback Plan

If migration fails:

1. **Immediate Rollback**:
   ```bash
   git checkout main
   git checkout -b migration-rollback
   git revert [migration-commits]
````

2. **User Communication**:
   - Announce rollback immediately
   - Provide workaround instructions
   - Set new timeline

3. **Recovery Actions**:
   - Restore from backups
   - Fix identified issues
   - Re-test thoroughly
   - Try again with fixes

## Success Criteria Validation

### Technical Validation

- [ ] All tests pass in new structure
- [ ] Generators work correctly
- [ ] Hooks function properly
- [ ] No circular dependencies
- [ ] Clean dependency tree

### User Experience Validation

- [ ] New user can create project in <2 minutes
- [ ] Existing user can migrate successfully
- [ ] Documentation is clear and accurate
- [ ] Support channels are responsive

### Performance Validation

- [ ] Starter creation <10 seconds
- [ ] Dependency install <60 seconds
- [ ] First component generation <5 seconds
- [ ] Development server start <3 seconds

## Conclusion

This technical implementation provides a complete roadmap for migrating AIPatternEnforcer from its current mixed state to a clean, focused meta-project that generates AI application starters. The key to success is careful planning, thorough testing, and clear communication with users throughout the process.
