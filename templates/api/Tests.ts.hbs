import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import request from 'supertest';
import { app } from '@/app';
import { {{name}}Service } from '@/services/{{kebabCase name}}.service';
import { {{name}}Repository } from '@/repositories/{{kebabCase name}}.repository';
import { testDb } from '@/tests/helpers/test-db';
import { createMock{{name}}, mock{{name}}Data } from '@/tests/fixtures/{{kebabCase name}}.fixtures';

/**
 * {{name}} API Tests
 * Comprehensive test suite for {{name}} endpoints
 */

describe('{{name}} API', () => {
  let {{camelCase name}}Service: {{name}}Service;
  let {{camelCase name}}Repository: {{name}}Repository;

  beforeEach(async () => {
    // Reset database
    await testDb.clear();
    
    // Initialize services
    {{camelCase name}}Repository = new {{name}}Repository();
    {{camelCase name}}Service = new {{name}}Service({{camelCase name}}Repository);
    
    // Clear all mocks
    vi.clearAllMocks();
  });

  afterEach(async () => {
    await testDb.clear();
  });

  describe('GET /api/{{kebabCase name}}s', () => {
    it('should return empty list when no {{name}}s exist', async () => {
      const response = await request(app)
        .get('/api/{{kebabCase name}}s')
        .expect(200);

      expect(response.body).toEqual({
        data: [],
        pagination: {
          page: 1,
          limit: 50,
          total: 0,
          pages: 0,
        },
      });
    });

    it('should return paginated list of {{name}}s', async () => {
      // Create test data
      const {{camelCase name}}1 = await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Test 1' }));
      const {{camelCase name}}2 = await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Test 2' }));

      const response = await request(app)
        .get('/api/{{kebabCase name}}s')
        .expect(200);

      expect(response.body.data).toHaveLength(2);
      expect(response.body.pagination.total).toBe(2);
      expect(response.body.data[0].name).toBe('Test 1');
      expect(response.body.data[1].name).toBe('Test 2');
    });

    it('should support pagination parameters', async () => {
      // Create test data
      for (let i = 1; i <= 5; i++) {
        await {{camelCase name}}Repository.create(createMock{{name}}({ name: `Test ${i}` }));
      }

      const response = await request(app)
        .get('/api/{{kebabCase name}}s?page=2&limit=2')
        .expect(200);

      expect(response.body.data).toHaveLength(2);
      expect(response.body.pagination.page).toBe(2);
      expect(response.body.pagination.limit).toBe(2);
      expect(response.body.pagination.total).toBe(5);
      expect(response.body.pagination.pages).toBe(3);
    });

    it('should support search functionality', async () => {
      await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Apple Product' }));
      await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Banana Product' }));

      const response = await request(app)
        .get('/api/{{kebabCase name}}s?search=Apple')
        .expect(200);

      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].name).toBe('Apple Product');
    });

    it('should support sorting', async () => {
      const {{camelCase name}}1 = await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Z Product' }));
      const {{camelCase name}}2 = await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'A Product' }));

      const response = await request(app)
        .get('/api/{{kebabCase name}}s?sortBy=name&sortOrder=asc')
        .expect(200);

      expect(response.body.data[0].name).toBe('A Product');
      expect(response.body.data[1].name).toBe('Z Product');
    });

    it('should validate query parameters', async () => {
      const response = await request(app)
        .get('/api/{{kebabCase name}}s?page=0&limit=101')
        .expect(400);

      expect(response.body.error).toBe('VALIDATION_ERROR');
      expect(response.body.message).toBe('Invalid query parameters');
    });
  });

  describe('GET /api/{{kebabCase name}}s/:id', () => {
    it('should return {{name}} by ID', async () => {
      const {{camelCase name}} = await {{camelCase name}}Repository.create(createMock{{name}}());

      const response = await request(app)
        .get(`/api/{{kebabCase name}}s/${{{camelCase name}}.id}`)
        .expect(200);

      expect(response.body.data.id).toBe({{camelCase name}}.id);
      expect(response.body.data.name).toBe({{camelCase name}}.name);
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const response = await request(app)
        .get('/api/{{kebabCase name}}s/550e8400-e29b-41d4-a716-446655440000')
        .expect(404);

      expect(response.body.error).toBe('NOT_FOUND');
      expect(response.body.message).toBe('{{name}} not found');
    });

    it('should return 400 for invalid ID format', async () => {
      const response = await request(app)
        .get('/api/{{kebabCase name}}s/invalid-id')
        .expect(400);

      expect(response.body.error).toBe('VALIDATION_ERROR');
    });
  });

  describe('POST /api/{{kebabCase name}}s', () => {
    it('should create new {{name}} with valid data', async () => {
      const {{camelCase name}}Data = {
        name: 'New {{name}}',
        description: 'Test description',
      };

      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({{camelCase name}}Data)
        .expect(201);

      expect(response.body.data.name).toBe({{camelCase name}}Data.name);
      expect(response.body.data.description).toBe({{camelCase name}}Data.description);
      expect(response.body.data.id).toBeDefined();
      expect(response.body.message).toBe('{{name}} created successfully');
    });

    it('should create {{name}} with minimal data', async () => {
      const {{camelCase name}}Data = {
        name: 'Minimal {{name}}',
      };

      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({{camelCase name}}Data)
        .expect(201);

      expect(response.body.data.name).toBe({{camelCase name}}Data.name);
      expect(response.body.data.description).toBeNull();
    });

    it('should validate required fields', async () => {
      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({})
        .expect(400);

      expect(response.body.error).toBe('VALIDATION_ERROR');
      expect(response.body.details).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            path: ['name'],
            message: expect.stringContaining('required'),
          }),
        ])
      );
    });

    it('should validate field lengths', async () => {
      const {{camelCase name}}Data = {
        name: 'a'.repeat(256), // Too long
        description: 'b'.repeat(1001), // Too long
      };

      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({{camelCase name}}Data)
        .expect(400);

      expect(response.body.error).toBe('VALIDATION_ERROR');
      expect(response.body.details).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            path: ['name'],
            message: expect.stringContaining('255'),
          }),
          expect.objectContaining({
            path: ['description'],
            message: expect.stringContaining('1000'),
          }),
        ])
      );
    });

    it('should trim whitespace from name', async () => {
      const {{camelCase name}}Data = {
        name: '  Trimmed {{name}}  ',
      };

      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({{camelCase name}}Data)
        .expect(201);

      expect(response.body.data.name).toBe('Trimmed {{name}}');
    });
  });

  describe('PUT /api/{{kebabCase name}}s/:id', () => {
    it('should update existing {{name}}', async () => {
      const {{camelCase name}} = await {{camelCase name}}Repository.create(createMock{{name}}());
      const updateData = {
        name: 'Updated {{name}}',
        description: 'Updated description',
      };

      const response = await request(app)
        .put(`/api/{{kebabCase name}}s/${{{camelCase name}}.id}`)
        .send(updateData)
        .expect(200);

      expect(response.body.data.name).toBe(updateData.name);
      expect(response.body.data.description).toBe(updateData.description);
      expect(response.body.message).toBe('{{name}} updated successfully');
    });

    it('should update partial data', async () => {
      const {{camelCase name}} = await {{camelCase name}}Repository.create(createMock{{name}}({ name: 'Original' }));
      const updateData = {
        name: 'Updated Name Only',
      };

      const response = await request(app)
        .put(`/api/{{kebabCase name}}s/${{{camelCase name}}.id}`)
        .send(updateData)
        .expect(200);

      expect(response.body.data.name).toBe(updateData.name);
      expect(response.body.data.description).toBe({{camelCase name}}.description);
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const updateData = {
        name: 'Updated {{name}}',
      };

      const response = await request(app)
        .put('/api/{{kebabCase name}}s/550e8400-e29b-41d4-a716-446655440000')
        .send(updateData)
        .expect(404);

      expect(response.body.error).toBe('NOT_FOUND');
    });

    it('should validate update data', async () => {
      const {{camelCase name}} = await {{camelCase name}}Repository.create(createMock{{name}}());
      const updateData = {
        name: 'a'.repeat(256), // Too long
      };

      const response = await request(app)
        .put(`/api/{{kebabCase name}}s/${{{camelCase name}}.id}`)
        .send(updateData)
        .expect(400);

      expect(response.body.error).toBe('VALIDATION_ERROR');
    });
  });

  describe('DELETE /api/{{kebabCase name}}s/:id', () => {
    it('should delete existing {{name}}', async () => {
      const {{camelCase name}} = await {{camelCase name}}Repository.create(createMock{{name}}());

      const response = await request(app)
        .delete(`/api/{{kebabCase name}}s/${{{camelCase name}}.id}`)
        .expect(200);

      expect(response.body.message).toBe('{{name}} deleted successfully');

      // Verify {{name}} is deleted
      const deleted{{name}} = await {{camelCase name}}Repository.findById({{camelCase name}}.id);
      expect(deleted{{name}}).toBeNull();
    });

    it('should return 404 for non-existent {{name}}', async () => {
      const response = await request(app)
        .delete('/api/{{kebabCase name}}s/550e8400-e29b-41d4-a716-446655440000')
        .expect(404);

      expect(response.body.error).toBe('NOT_FOUND');
    });
  });

  describe('Error Handling', () => {
    it('should handle database errors gracefully', async () => {
      // Mock database error
      vi.spyOn({{camelCase name}}Repository, 'findMany').mockRejectedValue(new Error('Database error'));

      const response = await request(app)
        .get('/api/{{kebabCase name}}s')
        .expect(500);

      expect(response.body.error).toBe('INTERNAL_SERVER_ERROR');
      expect(response.body.message).toBe('An unexpected error occurred');
    });

    it('should include timestamp in error responses', async () => {
      const response = await request(app)
        .get('/api/{{kebabCase name}}s/invalid-id')
        .expect(400);

      expect(response.body.timestamp).toBeDefined();
      expect(new Date(response.body.timestamp)).toBeInstanceOf(Date);
    });
  });

  describe('Authentication & Authorization', () => {
    it('should require authentication for protected endpoints', async () => {
      const response = await request(app)
        .post('/api/{{kebabCase name}}s')
        .send({ name: 'Test' })
        .expect(401);

      expect(response.body.error).toBe('UNAUTHORIZED');
    });

    // TODO: Add more auth tests based on your auth implementation
  });

  describe('Rate Limiting', () => {
    it('should enforce rate limits', async () => {
      // TODO: Implement rate limiting tests
      // This depends on your rate limiting implementation
    });
  });
});

// Integration tests for service layer
describe('{{name}} Service', () => {
  let service: {{name}}Service;
  let repository: {{name}}Repository;

  beforeEach(async () => {
    await testDb.clear();
    repository = new {{name}}Repository();
    service = new {{name}}Service(repository);
  });

  describe('findMany', () => {
    it('should return paginated results', async () => {
      // Create test data
      await repository.create(createMock{{name}}({ name: 'Test 1' }));
      await repository.create(createMock{{name}}({ name: 'Test 2' }));

      const result = await service.findMany({ page: 1, limit: 10 });

      expect(result.data).toHaveLength(2);
      expect(result.total).toBe(2);
      expect(result.page).toBe(1);
      expect(result.limit).toBe(10);
    });

    it('should handle empty results', async () => {
      const result = await service.findMany({ page: 1, limit: 10 });

      expect(result.data).toHaveLength(0);
      expect(result.total).toBe(0);
    });
  });

  describe('create', () => {
    it('should create {{name}} with valid data', async () => {
      const input = createMock{{name}}();
      const result = await service.create(input);

      expect(result.name).toBe(input.name);
      expect(result.id).toBeDefined();
      expect(result.createdAt).toBeInstanceOf(Date);
    });

    it('should validate business rules', async () => {
      // TODO: Add business rule validation tests
    });
  });

  describe('update', () => {
    it('should update existing {{name}}', async () => {
      const {{camelCase name}} = await repository.create(createMock{{name}}());
      const updateData = { name: 'Updated Name' };

      const result = await service.update({{camelCase name}}.id, updateData);

      expect(result?.name).toBe(updateData.name);
      expect(result?.id).toBe({{camelCase name}}.id);
    });

    it('should return null for non-existent {{name}}', async () => {
      const result = await service.update('550e8400-e29b-41d4-a716-446655440000', { name: 'Test' });

      expect(result).toBeNull();
    });
  });

  describe('delete', () => {
    it('should delete existing {{name}}', async () => {
      const {{camelCase name}} = await repository.create(createMock{{name}}());

      const result = await service.delete({{camelCase name}}.id);

      expect(result).toBe(true);
    });

    it('should return false for non-existent {{name}}', async () => {
      const result = await service.delete('550e8400-e29b-41d4-a716-446655440000');

      expect(result).toBe(false);
    });
  });
});

// Unit tests for repository layer
describe('{{name}} Repository', () => {
  let repository: {{name}}Repository;

  beforeEach(async () => {
    await testDb.clear();
    repository = new {{name}}Repository();
  });

  describe('findById', () => {
    it('should return {{name}} by ID', async () => {
      const {{camelCase name}} = await repository.create(createMock{{name}}());

      const result = await repository.findById({{camelCase name}}.id);

      expect(result?.id).toBe({{camelCase name}}.id);
      expect(result?.name).toBe({{camelCase name}}.name);
    });

    it('should return null for non-existent ID', async () => {
      const result = await repository.findById('550e8400-e29b-41d4-a716-446655440000');

      expect(result).toBeNull();
    });
  });

  describe('create', () => {
    it('should create {{name}} with generated ID and timestamps', async () => {
      const input = createMock{{name}}();
      const result = await repository.create(input);

      expect(result.id).toBeDefined();
      expect(result.createdAt).toBeInstanceOf(Date);
      expect(result.updatedAt).toBeInstanceOf(Date);
      expect(result.name).toBe(input.name);
    });
  });

  describe('exists', () => {
    it('should return true for existing {{name}}', async () => {
      const {{camelCase name}} = await repository.create(createMock{{name}}());

      const result = await repository.exists({{camelCase name}}.id);

      expect(result).toBe(true);
    });

    it('should return false for non-existent {{name}}', async () => {
      const result = await repository.exists('550e8400-e29b-41d4-a716-446655440000');

      expect(result).toBe(false);
    });
  });

  describe('count', () => {
    it('should return correct count', async () => {
      await repository.create(createMock{{name}}());
      await repository.create(createMock{{name}}());

      const result = await repository.count();

      expect(result).toBe(2);
    });

    it('should return 0 for empty collection', async () => {
      const result = await repository.count();

      expect(result).toBe(0);
    });
  });
});